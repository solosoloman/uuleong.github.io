{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 1: The Doomsday Algorithm\n",
    "\n",
    "The Doomsday algorithm, devised by mathematician J. H. Conway, computes the day of the week any given date fell on. The algorithm is designed to be simple enough to memorize and use for mental calculation.\n",
    "\n",
    "__Example.__ With the algorithm, we can compute that July 4, 1776 (the day the United States declared independence from Great Britain) was a Thursday.\n",
    "\n",
    "The algorithm is based on the fact that for any year, several dates always fall on the same day of the week, called the <em style=\"color:#F00\">doomsday</em> for the year. These dates include 4/4, 6/6, 8/8, 10/10, and 12/12.\n",
    "\n",
    "__Example.__ The doomsday for 2016 is Monday, so in 2016 the dates above all fell on Mondays. The doomsday for 2017 is Tuesday, so in 2017 the dates above will all fall on Tuesdays.\n",
    "\n",
    "The doomsday algorithm has three major steps:\n",
    "\n",
    "1. Compute the anchor day for the target century.\n",
    "2. Compute the doomsday for the target year based on the anchor day.\n",
    "3. Determine the day of week for the target date by counting the number of days to the nearest doomsday.\n",
    "\n",
    "Each step is explained in detail below."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Anchor Day\n",
    "\n",
    "The doomsday for the first year in a century is called the <em style=\"color:#F00\">anchor day</em> for that century. The anchor day is needed to compute the doomsday for any other year in that century. The anchor day for a century $c$ can be computed with the formula:\n",
    "$$\n",
    "a = \\bigl( 5 (c \\bmod 4) + 2 \\bigr) \\bmod 7\n",
    "$$\n",
    "The result $a$ corresponds to a day of the week, starting with $0$ for Sunday and ending with $6$ for Saturday.\n",
    "\n",
    "__Note.__ The modulo operation $(x \\bmod y)$ finds the remainder after dividing $x$ by $y$. For instance, $12 \\bmod 3 = 0$ since the remainder after dividing $12$ by $3$ is $0$. Similarly, $11 \\bmod 7 = 4$, since the remainder after dividing $11$ by $7$ is $4$.\n",
    "\n",
    "__Example.__ Suppose the target year is 1954, so the century is $c = 19$. Plugging this into the formula gives\n",
    "$$a = \\bigl( 5 (19 \\bmod 4) + 2 \\bigr) \\bmod 7 = \\bigl( 5(3) + 2 \\bigr) \\bmod 7 = 3.$$\n",
    "In other words, the anchor day for 1900-1999 is Wednesday, which is also the doomsday for 1900.\n",
    "\n",
    "__Exercise 1.1.__ Write a function that accepts a year as input and computes the anchor day for that year's century. The modulo operator `%` and functions in the `math` module may be useful. Document your function with a docstring and test your function for a few different years.  Do this in a new cell below this one."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# this function takes in the year \n",
    "# converts the year into a string \n",
    "# take the century of the year \n",
    "# converts the strin back into an integer\n",
    "# and returns the anchor day \n",
    "def anchor_day(year):\n",
    "    c = str(year)\n",
    "    c = c[:2]\n",
    "    c = int(c)\n",
    "    return (5*(c%4)+2)%7"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "testing if anchor_day function works "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 93,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "anchor_day(1954)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Doomsday\n",
    "\n",
    "Once the anchor day is known, let $y$ be the last two digits of the target year. Then the doomsday for the target year can be computed with the formula:\n",
    "$$d = \\left(y + \\left\\lfloor\\frac{y}{4}\\right\\rfloor + a\\right) \\bmod 7$$\n",
    "The result $d$ corresponds to a day of the week.\n",
    "\n",
    "__Note.__ The floor operation $\\lfloor x \\rfloor$ rounds $x$ down to the nearest integer. For instance, $\\lfloor 3.1 \\rfloor = 3$ and $\\lfloor 3.8 \\rfloor = 3$.\n",
    "\n",
    "__Example.__ Again suppose the target year is 1954. Then the anchor day is $a = 3$, and $y = 54$, so the formula gives\n",
    "$$\n",
    "d = \\left(54 + \\left\\lfloor\\frac{54}{4}\\right\\rfloor + 3\\right) \\bmod 7 = (54 + 13 + 3) \\bmod 7 = 0.\n",
    "$$\n",
    "Thus the doomsday for 1954 is Sunday.\n",
    "\n",
    "__Exercise 1.2.__ Write a function that accepts a year as input and computes the doomsday for that year. Your function may need to call the function you wrote in exercise 1.1. Make sure to document and test your function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# this function takes year as an input \n",
    "# gets the last two digits \n",
    "# calls the function anchor_day and returns the doomsday\n",
    "import math\n",
    "def doomsday(year):\n",
    "    y = year % 100\n",
    "    a = anchor_day(year)\n",
    "    return int((y + math.floor(y/4) + a) % 7)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 181,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 181,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "doomsday(1978)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The Day of Week\n",
    "\n",
    "The final step in the Doomsday algorithm is to count the number of days between the target date and a nearby doomsday, modulo 7. This gives the day of the week.\n",
    "\n",
    "Every month has at least one doomsday:\n",
    "* (regular years) 1/10, 2/28\n",
    "* (leap years) 1/11, 2/29\n",
    "* 3/21, 4/4, 5/9, 6/6, 7/11, 8/8, 9/5, 10/10, 11/7, 12/12\n",
    "\n",
    "__Example.__ Suppose we want to find the day of the week for 7/21/1954. The doomsday for 1954 is Sunday, and a nearby doomsday is 7/11. There are 10 days in July between 7/11 and 7/21. Since $10 \\bmod 7 = 3$, the date 7/21/1954 falls 3 days after a Sunday, on a Wednesday.\n",
    "\n",
    "__Exercise 1.3.__ Write a function to determine the day of the week for a given day, month, and year. Be careful of leap years! Your function should return a string such as \"Thursday\" rather than a number. As usual, document and test your code."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# this function returns whether the year is a leap year or not\n",
    "# 1 means leap year\n",
    "# 0 means not a leap year\n",
    "def leap_year(year):\n",
    "    if (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0):\n",
    "        return 1\n",
    "    else:\n",
    "        return 0\n",
    "     "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 182,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 182,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "leap_year(1978)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 319,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Saturday'"
      ]
     },
     "execution_count": 319,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# this function takes in the input of month, date, and year\n",
    "# and returns the day of the week the date is \n",
    "\n",
    "def day_of_week(month, date, year):\n",
    "    \n",
    "    # list out the doomsday for both leap year and non-leap year \n",
    "    leap_days = [11, 29, 21, 4, 9, 6, 11, 8, 5, 10, 7, 12]\n",
    "    non_leap_days = [10, 28, 21, 4, 9, 6, 11, 8, 5, 10, 7, 12]\n",
    "    \n",
    "    # list out the days of the week as a string \n",
    "    word_of_days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n",
    "    \n",
    "    # check if the year is a leap year or not\n",
    "    leapyear = leap_year(year)\n",
    "    \n",
    "    # get the doomsday for the year\n",
    "    dooms_day = doomsday(year)\n",
    "    #print dooms_day\n",
    "    \n",
    "    # if it is a leap year, use the leap year list\n",
    "    if leapyear == 1:\n",
    "        dday = leap_days[month - 1]\n",
    "        # if the date is the same as the doomsday of that month, return the day for the doomsday of that month \n",
    "        if date == dday:\n",
    "            day_word = word_of_days[dooms_day]\n",
    "            return day_word\n",
    "        # if the date is greater than the doomsday of that month, date - doomsday of that month\n",
    "        if date > dday:\n",
    "            day = date - dday\n",
    "            day = day % 7\n",
    "            day = day + dooms_day\n",
    "            # if the day is greater than 6, get the remainder to get the day of the week\n",
    "            if day > 6:\n",
    "                day = day % 7\n",
    "                day_word = word_of_days[day]\n",
    "                return day_word\n",
    "            else:\n",
    "                day_word = word_of_days[day]\n",
    "                return day_word\n",
    "        # if the date is less than the doomsday of that month, doomsday of that month - date\n",
    "        if date < dday:\n",
    "            day = dday - date\n",
    "            day = day % 7 \n",
    "            day = dooms_day - day\n",
    "            day_word = word_of_days[day]\n",
    "            return day_word\n",
    "    \n",
    "    # if it is not a leap year, use the non-leap year list\n",
    "    if leapyear == 0:\n",
    "        dday = non_leap_days[month - 1]\n",
    "        if date == dday:\n",
    "            day_word = word_of_days[dooms_day]\n",
    "            return day_word\n",
    "        if date > dday:\n",
    "            day = date - dday\n",
    "            day = day % 7\n",
    "            day = day + dooms_day\n",
    "            if day > 6:\n",
    "                day = day % 7\n",
    "                day_word = word_of_days[day]\n",
    "                return day_word\n",
    "            else:\n",
    "                day_word = word_of_days[day]\n",
    "                return day_word\n",
    "        if date < dday:\n",
    "            day = dday - date\n",
    "            day = day % 7 \n",
    "            day = dooms_day - day\n",
    "            day_word = word_of_days[day]\n",
    "            return day_word\n",
    "\n",
    "# test today's date         \n",
    "day_of_week(1,21,2017)    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Exercise 1.4.__ How many times did Friday the 13th occur in the years 1900-1999? Does this number seem to be similar to other centuries?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 326,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "172"
      ]
     },
     "execution_count": 326,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# this function takes in two years\n",
    "# and returns how many Friday the 13th appeared between those two years \n",
    "\n",
    "def num_13_friday(year_start, year_end):\n",
    "    # set the initial count to zero and date to 13\n",
    "    i = 0 \n",
    "    date = 13\n",
    "    # go through the beginning year to the end year\n",
    "    for year in xrange(year_start, year_end + 1,1):\n",
    "        # go through each month\n",
    "        for month in range(1,13):\n",
    "            # check if the day of the week is equal to Friday\n",
    "            if day_of_week(month, date, year) == 'Friday':\n",
    "                # if it is, add it to the initial count\n",
    "                i = i + 1\n",
    "                \n",
    "    return i \n",
    "\n",
    "num_13_friday(1900,1999)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 347,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "172\n",
      "172\n",
      "172\n"
     ]
    }
   ],
   "source": [
    "print num_13_friday(1800, 1899)\n",
    "print num_13_friday(1700, 1799)\n",
    "print num_13_friday(1600, 1699)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There were 172 Friday the 13th between the years 1900 and 1999. This seems to be similar in other centuries."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Exercise 1.5.__ How many times did Friday the 13th occur between the year 2000 and today?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 328,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "30"
      ]
     },
     "execution_count": 328,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# this function takes in today's date \n",
    "# and returns how many Friday the 13th occurred\n",
    "# from 2000 to today's date \n",
    "\n",
    "def num_of_friday_2(today_month, today_date, today_year):\n",
    "    i = 0\n",
    "    date = 13\n",
    "    # get the number of Friday the 13 before the year of input\n",
    "    for year in range(2000, today_year):\n",
    "        for month in xrange(1,13,1):\n",
    "            if day_of_week(month, date, year) == 'Friday':\n",
    "                i = i + 1\n",
    "    # get the number of Friday the 13 for the year of input\n",
    "    \n",
    "    # if the date is less than 13, then check the previous month that was inputted \n",
    "    if today_date < 13:\n",
    "        for month in xrange(1, today_month, 1):\n",
    "            if day_of_week(month, 13, today_year) == 'Friday':\n",
    "                i = i + 1 \n",
    "    # if the date is greater than 13, then check the month that was inputed \n",
    "    if today_date >= 13:\n",
    "        for month in xrange(1, today_month + 1, 1):\n",
    "            if day_of_week(month, 13, today_year) == 'Friday':\n",
    "                i = i + 1\n",
    "    return i\n",
    "\n",
    "num_of_friday_2(1,21,2017)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Friday the 13th occured 30 times between the year 2000 and today. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Part 2: 1978 Birthdays\n",
    "\n",
    "__Exercise 2.1.__ The file `birthdays.txt` contains the number of births in the United States for each day in 1978. Inspect the file to determine the format. Note that columns are separated by the tab character, which can be entered in Python as `\\t`. Write a function that uses iterators and list comprehensions with the string methods `split()` and `strip()` to  convert each line of data to the list format\n",
    "\n",
    "```Python\n",
    "[month, day, year, count]\n",
    "```\n",
    "The elements of this list should be integers, not strings. The function `read_birthdays` provided below will help you load the file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def read_birthdays(file_path):\n",
    "    \"\"\"Read the contents of the birthdays file into a string.\n",
    "    \n",
    "    Arguments:\n",
    "        file_path (string): The path to the birthdays file.\n",
    "        \n",
    "    Returns:\n",
    "        string: The contents of the birthdays file.\n",
    "    \"\"\"\n",
    "    with open(file_path) as file:\n",
    "        return file.read()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 330,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# read in the birthday.txt\n",
    "bday = read_birthdays('birthdays.txt')\n",
    "# get rid of all beginning and the end of the text\n",
    "bday = bday.strip()\n",
    "# split by the \\n\\n \n",
    "bday = bday.split('\\n\\n')[2]\n",
    "# split it again by the \\n\n",
    "bday = bday.split('\\n')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 331,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{0: [1, 1, 78, 7701],\n",
       " 1: [1, 2, 78, 7527],\n",
       " 2: [1, 3, 78, 8825],\n",
       " 3: [1, 4, 78, 8859],\n",
       " 4: [1, 5, 78, 9043],\n",
       " 5: [1, 6, 78, 9208],\n",
       " 6: [1, 7, 78, 8084],\n",
       " 7: [1, 8, 78, 7611],\n",
       " 8: [1, 9, 78, 9172],\n",
       " 9: [1, 10, 78, 9089],\n",
       " 10: [1, 11, 78, 9210],\n",
       " 11: [1, 12, 78, 9259],\n",
       " 12: [1, 13, 78, 9138],\n",
       " 13: [1, 14, 78, 8299],\n",
       " 14: [1, 15, 78, 7771],\n",
       " 15: [1, 16, 78, 9458],\n",
       " 16: [1, 17, 78, 9339],\n",
       " 17: [1, 18, 78, 9120],\n",
       " 18: [1, 19, 78, 9226],\n",
       " 19: [1, 20, 78, 9305],\n",
       " 20: [1, 21, 78, 7954],\n",
       " 21: [1, 22, 78, 7560],\n",
       " 22: [1, 23, 78, 9252],\n",
       " 23: [1, 24, 78, 9416],\n",
       " 24: [1, 25, 78, 9090],\n",
       " 25: [1, 26, 78, 9387],\n",
       " 26: [1, 27, 78, 8983],\n",
       " 27: [1, 28, 78, 7946],\n",
       " 28: [1, 29, 78, 7527],\n",
       " 29: [1, 30, 78, 9184],\n",
       " 30: [1, 31, 78, 9152],\n",
       " 31: [2, 1, 78, 9159],\n",
       " 32: [2, 2, 78, 9218],\n",
       " 33: [2, 3, 78, 9167],\n",
       " 34: [2, 4, 78, 8065],\n",
       " 35: [2, 5, 78, 7804],\n",
       " 36: [2, 6, 78, 9225],\n",
       " 37: [2, 7, 78, 9328],\n",
       " 38: [2, 8, 78, 9139],\n",
       " 39: [2, 9, 78, 9247],\n",
       " 40: [2, 10, 78, 9527],\n",
       " 41: [2, 11, 78, 8144],\n",
       " 42: [2, 12, 78, 7950],\n",
       " 43: [2, 13, 78, 8966],\n",
       " 44: [2, 14, 78, 9859],\n",
       " 45: [2, 15, 78, 9285],\n",
       " 46: [2, 16, 78, 9103],\n",
       " 47: [2, 17, 78, 9238],\n",
       " 48: [2, 18, 78, 8167],\n",
       " 49: [2, 19, 78, 7695],\n",
       " 50: [2, 20, 78, 9021],\n",
       " 51: [2, 21, 78, 9252],\n",
       " 52: [2, 22, 78, 9335],\n",
       " 53: [2, 23, 78, 9268],\n",
       " 54: [2, 24, 78, 9552],\n",
       " 55: [2, 25, 78, 8313],\n",
       " 56: [2, 26, 78, 7881],\n",
       " 57: [2, 27, 78, 9262],\n",
       " 58: [2, 28, 78, 9705],\n",
       " 59: [3, 1, 78, 9132],\n",
       " 60: [3, 2, 78, 9304],\n",
       " 61: [3, 3, 78, 9431],\n",
       " 62: [3, 4, 78, 8008],\n",
       " 63: [3, 5, 78, 7791],\n",
       " 64: [3, 6, 78, 9294],\n",
       " 65: [3, 7, 78, 9573],\n",
       " 66: [3, 8, 78, 9212],\n",
       " 67: [3, 9, 78, 9218],\n",
       " 68: [3, 10, 78, 9583],\n",
       " 69: [3, 11, 78, 8144],\n",
       " 70: [3, 12, 78, 7870],\n",
       " 71: [3, 13, 78, 9022],\n",
       " 72: [3, 14, 78, 9525],\n",
       " 73: [3, 15, 78, 9284],\n",
       " 74: [3, 16, 78, 9327],\n",
       " 75: [3, 17, 78, 9480],\n",
       " 76: [3, 18, 78, 7965],\n",
       " 77: [3, 19, 78, 7729],\n",
       " 78: [3, 20, 78, 9135],\n",
       " 79: [3, 21, 78, 9663],\n",
       " 80: [3, 22, 78, 9307],\n",
       " 81: [3, 23, 78, 9159],\n",
       " 82: [3, 24, 78, 9157],\n",
       " 83: [3, 25, 78, 7874],\n",
       " 84: [3, 26, 78, 7589],\n",
       " 85: [3, 27, 78, 9100],\n",
       " 86: [3, 28, 78, 9293],\n",
       " 87: [3, 29, 78, 9195],\n",
       " 88: [3, 30, 78, 8902],\n",
       " 89: [3, 31, 78, 9318],\n",
       " 90: [4, 1, 78, 8069],\n",
       " 91: [4, 2, 78, 7691],\n",
       " 92: [4, 3, 78, 9114],\n",
       " 93: [4, 4, 78, 9439],\n",
       " 94: [4, 5, 78, 8852],\n",
       " 95: [4, 6, 78, 8969],\n",
       " 96: [4, 7, 78, 9077],\n",
       " 97: [4, 8, 78, 7890],\n",
       " 98: [4, 9, 78, 7445],\n",
       " 99: [4, 10, 78, 8870],\n",
       " 100: [4, 11, 78, 9023],\n",
       " 101: [4, 12, 78, 8606],\n",
       " 102: [4, 13, 78, 8724],\n",
       " 103: [4, 14, 78, 9012],\n",
       " 104: [4, 15, 78, 7527],\n",
       " 105: [4, 16, 78, 7193],\n",
       " 106: [4, 17, 78, 8702],\n",
       " 107: [4, 18, 78, 9205],\n",
       " 108: [4, 19, 78, 8720],\n",
       " 109: [4, 20, 78, 8582],\n",
       " 110: [4, 21, 78, 8892],\n",
       " 111: [4, 22, 78, 7787],\n",
       " 112: [4, 23, 78, 7304],\n",
       " 113: [4, 24, 78, 9017],\n",
       " 114: [4, 25, 78, 9077],\n",
       " 115: [4, 26, 78, 9019],\n",
       " 116: [4, 27, 78, 8839],\n",
       " 117: [4, 28, 78, 9047],\n",
       " 118: [4, 29, 78, 7750],\n",
       " 119: [4, 30, 78, 7135],\n",
       " 120: [5, 1, 78, 8900],\n",
       " 121: [5, 2, 78, 9422],\n",
       " 122: [5, 3, 78, 9051],\n",
       " 123: [5, 4, 78, 8672],\n",
       " 124: [5, 5, 78, 9101],\n",
       " 125: [5, 6, 78, 7718],\n",
       " 126: [5, 7, 78, 7388],\n",
       " 127: [5, 8, 78, 8987],\n",
       " 128: [5, 9, 78, 9307],\n",
       " 129: [5, 10, 78, 9273],\n",
       " 130: [5, 11, 78, 8903],\n",
       " 131: [5, 12, 78, 8975],\n",
       " 132: [5, 13, 78, 7762],\n",
       " 133: [5, 14, 78, 7382],\n",
       " 134: [5, 15, 78, 9195],\n",
       " 135: [5, 16, 78, 9200],\n",
       " 136: [5, 17, 78, 8913],\n",
       " 137: [5, 18, 78, 9044],\n",
       " 138: [5, 19, 78, 9000],\n",
       " 139: [5, 20, 78, 8064],\n",
       " 140: [5, 21, 78, 7570],\n",
       " 141: [5, 22, 78, 9089],\n",
       " 142: [5, 23, 78, 9210],\n",
       " 143: [5, 24, 78, 9196],\n",
       " 144: [5, 25, 78, 9180],\n",
       " 145: [5, 26, 78, 9514],\n",
       " 146: [5, 27, 78, 8005],\n",
       " 147: [5, 28, 78, 7781],\n",
       " 148: [5, 29, 78, 7780],\n",
       " 149: [5, 30, 78, 9630],\n",
       " 150: [5, 31, 78, 9600],\n",
       " 151: [6, 1, 78, 9435],\n",
       " 152: [6, 2, 78, 9303],\n",
       " 153: [6, 3, 78, 7971],\n",
       " 154: [6, 4, 78, 7399],\n",
       " 155: [6, 5, 78, 9127],\n",
       " 156: [6, 6, 78, 9606],\n",
       " 157: [6, 7, 78, 9328],\n",
       " 158: [6, 8, 78, 9075],\n",
       " 159: [6, 9, 78, 9362],\n",
       " 160: [6, 10, 78, 8040],\n",
       " 161: [6, 11, 78, 7581],\n",
       " 162: [6, 12, 78, 9201],\n",
       " 163: [6, 13, 78, 9264],\n",
       " 164: [6, 14, 78, 9216],\n",
       " 165: [6, 15, 78, 9175],\n",
       " 166: [6, 16, 78, 9350],\n",
       " 167: [6, 17, 78, 8233],\n",
       " 168: [6, 18, 78, 7777],\n",
       " 169: [6, 19, 78, 9543],\n",
       " 170: [6, 20, 78, 9672],\n",
       " 171: [6, 21, 78, 9266],\n",
       " 172: [6, 22, 78, 9405],\n",
       " 173: [6, 23, 78, 9598],\n",
       " 174: [6, 24, 78, 8122],\n",
       " 175: [6, 25, 78, 8091],\n",
       " 176: [6, 26, 78, 9348],\n",
       " 177: [6, 27, 78, 9857],\n",
       " 178: [6, 28, 78, 9701],\n",
       " 179: [6, 29, 78, 9630],\n",
       " 180: [6, 30, 78, 10080],\n",
       " 181: [7, 1, 78, 8209],\n",
       " 182: [7, 2, 78, 7976],\n",
       " 183: [7, 3, 78, 9284],\n",
       " 184: [7, 4, 78, 8433],\n",
       " 185: [7, 5, 78, 9675],\n",
       " 186: [7, 6, 78, 10184],\n",
       " 187: [7, 7, 78, 10241],\n",
       " 188: [7, 8, 78, 8773],\n",
       " 189: [7, 9, 78, 8102],\n",
       " 190: [7, 10, 78, 9877],\n",
       " 191: [7, 11, 78, 9852],\n",
       " 192: [7, 12, 78, 9705],\n",
       " 193: [7, 13, 78, 9984],\n",
       " 194: [7, 14, 78, 10438],\n",
       " 195: [7, 15, 78, 8859],\n",
       " 196: [7, 16, 78, 8416],\n",
       " 197: [7, 17, 78, 10026],\n",
       " 198: [7, 18, 78, 10357],\n",
       " 199: [7, 19, 78, 10015],\n",
       " 200: [7, 20, 78, 10386],\n",
       " 201: [7, 21, 78, 10332],\n",
       " 202: [7, 22, 78, 9062],\n",
       " 203: [7, 23, 78, 8563],\n",
       " 204: [7, 24, 78, 9960],\n",
       " 205: [7, 25, 78, 10349],\n",
       " 206: [7, 26, 78, 10091],\n",
       " 207: [7, 27, 78, 10192],\n",
       " 208: [7, 28, 78, 10307],\n",
       " 209: [7, 29, 78, 8677],\n",
       " 210: [7, 30, 78, 8486],\n",
       " 211: [7, 31, 78, 9890],\n",
       " 212: [8, 1, 78, 10145],\n",
       " 213: [8, 2, 78, 9824],\n",
       " 214: [8, 3, 78, 10128],\n",
       " 215: [8, 4, 78, 10051],\n",
       " 216: [8, 5, 78, 8738],\n",
       " 217: [8, 6, 78, 8442],\n",
       " 218: [8, 7, 78, 10206],\n",
       " 219: [8, 8, 78, 10442],\n",
       " 220: [8, 9, 78, 10142],\n",
       " 221: [8, 10, 78, 10284],\n",
       " 222: [8, 11, 78, 10162],\n",
       " 223: [8, 12, 78, 8951],\n",
       " 224: [8, 13, 78, 8532],\n",
       " 225: [8, 14, 78, 10127],\n",
       " 226: [8, 15, 78, 10502],\n",
       " 227: [8, 16, 78, 10053],\n",
       " 228: [8, 17, 78, 10377],\n",
       " 229: [8, 18, 78, 10355],\n",
       " 230: [8, 19, 78, 8904],\n",
       " 231: [8, 20, 78, 8477],\n",
       " 232: [8, 21, 78, 9967],\n",
       " 233: [8, 22, 78, 10229],\n",
       " 234: [8, 23, 78, 9900],\n",
       " 235: [8, 24, 78, 10152],\n",
       " 236: [8, 25, 78, 10173],\n",
       " 237: [8, 26, 78, 8782],\n",
       " 238: [8, 27, 78, 8453],\n",
       " 239: [8, 28, 78, 9998],\n",
       " 240: [8, 29, 78, 10387],\n",
       " 241: [8, 30, 78, 10063],\n",
       " 242: [8, 31, 78, 9849],\n",
       " 243: [9, 1, 78, 10114],\n",
       " 244: [9, 2, 78, 8580],\n",
       " 245: [9, 3, 78, 8355],\n",
       " 246: [9, 4, 78, 8481],\n",
       " 247: [9, 5, 78, 10023],\n",
       " 248: [9, 6, 78, 10703],\n",
       " 249: [9, 7, 78, 10292],\n",
       " 250: [9, 8, 78, 10371],\n",
       " 251: [9, 9, 78, 9023],\n",
       " 252: [9, 10, 78, 8630],\n",
       " 253: [9, 11, 78, 10154],\n",
       " 254: [9, 12, 78, 10425],\n",
       " 255: [9, 13, 78, 10149],\n",
       " 256: [9, 14, 78, 10265],\n",
       " 257: [9, 15, 78, 10265],\n",
       " 258: [9, 16, 78, 9170],\n",
       " 259: [9, 17, 78, 8711],\n",
       " 260: [9, 18, 78, 10304],\n",
       " 261: [9, 19, 78, 10711],\n",
       " 262: [9, 20, 78, 10488],\n",
       " 263: [9, 21, 78, 10499],\n",
       " 264: [9, 22, 78, 10349],\n",
       " 265: [9, 23, 78, 8735],\n",
       " 266: [9, 24, 78, 8647],\n",
       " 267: [9, 25, 78, 10414],\n",
       " 268: [9, 26, 78, 10498],\n",
       " 269: [9, 27, 78, 10344],\n",
       " 270: [9, 28, 78, 10175],\n",
       " 271: [9, 29, 78, 10368],\n",
       " 272: [9, 30, 78, 8648],\n",
       " 273: [10, 1, 78, 8686],\n",
       " 274: [10, 2, 78, 9927],\n",
       " 275: [10, 3, 78, 10378],\n",
       " 276: [10, 4, 78, 9928],\n",
       " 277: [10, 5, 78, 9949],\n",
       " 278: [10, 6, 78, 10052],\n",
       " 279: [10, 7, 78, 8605],\n",
       " 280: [10, 8, 78, 8377],\n",
       " 281: [10, 9, 78, 9765],\n",
       " 282: [10, 10, 78, 10351],\n",
       " 283: [10, 11, 78, 9873],\n",
       " 284: [10, 12, 78, 9824],\n",
       " 285: [10, 13, 78, 9755],\n",
       " 286: [10, 14, 78, 8554],\n",
       " 287: [10, 15, 78, 7873],\n",
       " 288: [10, 16, 78, 9531],\n",
       " 289: [10, 17, 78, 9938],\n",
       " 290: [10, 18, 78, 9388],\n",
       " 291: [10, 19, 78, 9502],\n",
       " 292: [10, 20, 78, 9625],\n",
       " 293: [10, 21, 78, 8411],\n",
       " 294: [10, 22, 78, 7936],\n",
       " 295: [10, 23, 78, 9425],\n",
       " 296: [10, 24, 78, 9576],\n",
       " 297: [10, 25, 78, 9328],\n",
       " 298: [10, 26, 78, 9501],\n",
       " 299: [10, 27, 78, 9537],\n",
       " 300: [10, 28, 78, 8415],\n",
       " 301: [10, 29, 78, 8155],\n",
       " 302: [10, 30, 78, 9457],\n",
       " 303: [10, 31, 78, 9333],\n",
       " 304: [11, 1, 78, 9321],\n",
       " 305: [11, 2, 78, 9245],\n",
       " 306: [11, 3, 78, 9774],\n",
       " 307: [11, 4, 78, 8246],\n",
       " 308: [11, 5, 78, 8011],\n",
       " 309: [11, 6, 78, 9507],\n",
       " 310: [11, 7, 78, 9769],\n",
       " 311: [11, 8, 78, 9501],\n",
       " 312: [11, 9, 78, 9609],\n",
       " 313: [11, 10, 78, 9652],\n",
       " 314: [11, 11, 78, 8352],\n",
       " 315: [11, 12, 78, 7967],\n",
       " 316: [11, 13, 78, 9606],\n",
       " 317: [11, 14, 78, 10014],\n",
       " 318: [11, 15, 78, 9536],\n",
       " 319: [11, 16, 78, 9568],\n",
       " 320: [11, 17, 78, 9835],\n",
       " 321: [11, 18, 78, 8432],\n",
       " 322: [11, 19, 78, 7868],\n",
       " 323: [11, 20, 78, 9592],\n",
       " 324: [11, 21, 78, 9950],\n",
       " 325: [11, 22, 78, 9548],\n",
       " 326: [11, 23, 78, 7915],\n",
       " 327: [11, 24, 78, 9037],\n",
       " 328: [11, 25, 78, 8275],\n",
       " 329: [11, 26, 78, 8068],\n",
       " 330: [11, 27, 78, 9825],\n",
       " 331: [11, 28, 78, 9814],\n",
       " 332: [11, 29, 78, 9438],\n",
       " 333: [11, 30, 78, 9396],\n",
       " 334: [12, 1, 78, 9592],\n",
       " 335: [12, 2, 78, 8528],\n",
       " 336: [12, 3, 78, 8196],\n",
       " 337: [12, 4, 78, 9767],\n",
       " 338: [12, 5, 78, 9881],\n",
       " 339: [12, 6, 78, 9402],\n",
       " 340: [12, 7, 78, 9480],\n",
       " 341: [12, 8, 78, 9398],\n",
       " 342: [12, 9, 78, 8335],\n",
       " 343: [12, 10, 78, 8093],\n",
       " 344: [12, 11, 78, 9686],\n",
       " 345: [12, 12, 78, 10063],\n",
       " 346: [12, 13, 78, 9509],\n",
       " 347: [12, 14, 78, 9524],\n",
       " 348: [12, 15, 78, 9951],\n",
       " 349: [12, 16, 78, 8507],\n",
       " 350: [12, 17, 78, 8172],\n",
       " 351: [12, 18, 78, 10196],\n",
       " 352: [12, 19, 78, 10605],\n",
       " 353: [12, 20, 78, 9998],\n",
       " 354: [12, 21, 78, 9398],\n",
       " 355: [12, 22, 78, 9008],\n",
       " 356: [12, 23, 78, 7939],\n",
       " 357: [12, 24, 78, 7964],\n",
       " 358: [12, 25, 78, 7846],\n",
       " 359: [12, 26, 78, 8902],\n",
       " 360: [12, 27, 78, 9907],\n",
       " 361: [12, 28, 78, 10177],\n",
       " 362: [12, 29, 78, 10401],\n",
       " 363: [12, 30, 78, 8474],\n",
       " 364: [12, 31, 78, 8028]}"
      ]
     },
     "execution_count": 331,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# set up empty dictionarys for the month, day, year, count, and the final format of the birthdays\n",
    "month = {}\n",
    "day = {}\n",
    "year = {}\n",
    "count = {}\n",
    "final_format = {}\n",
    "\n",
    "# go through the list of all the birthdays\n",
    "for i in range(0, len(bday)):\n",
    "    # grab the month, day, and year + count from the list splitting on /\n",
    "    month[i], day[i], year[i] = bday[i].split('/')\n",
    "    # get the actual year and count from the year + count splitting on \\t  \n",
    "    year[i], count[i] = year[i].split('\\t')\n",
    "    # convert the format to integers\n",
    "    final_format[i] = [int(month[i]) , int(day[i]) , int(year[i]) , int(count[i])]\n",
    "final_format"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 333,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3333239"
      ]
     },
     "execution_count": 333,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# check the total number of counts of births to double check my work later\n",
    "total_count = 0\n",
    "for i in range(0, len(final_format)):\n",
    "    element = final_format[i]\n",
    "    counts = element[3]\n",
    "    total_count = total_count + counts\n",
    "total_count    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Exercise 2.2.__ Which month had the most births in 1978? Which day of the week had the most births? Which day of the week had the fewest? What conclusions can you draw? You may find the `Counter` class in the `collections` module useful."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 340,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[270695, 249875, 276584, 254577, 270812, 270756, 294701, 302795, 293891, 288955, 274671, 284927]\n"
     ]
    }
   ],
   "source": [
    "tmp_num_births = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n",
    "months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12]\n",
    "count = 0\n",
    "\n",
    "# loop through the list of all the birthdays\n",
    "for i in range(0, len(final_format)):\n",
    "    # store the ith element of list\n",
    "    ith_element = final_format[i]\n",
    "    # store the month and count of the ith element\n",
    "    the_month = ith_element[0]\n",
    "    the_count = ith_element[3]\n",
    "    #if the_month != months[the_month -1]:\n",
    "        #count = 0 \n",
    "    # if the month is the same as in the list of months\n",
    "    if the_month == months[the_month - 1]:\n",
    "        # for the same month, add the counts up\n",
    "        count = count + the_count\n",
    "        # store the counts in a list\n",
    "        tmp_num_births[the_month - 1] = count\n",
    "\n",
    "# need to subtract off the previous element of tmp_num_births to get the right num_births for each month       \n",
    "num_births = [tmp_num_births[0], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]        \n",
    "for i in range(1, len(tmp_num_births)):\n",
    "    num_births[i] = tmp_num_births[i] - tmp_num_births[i-1]\n",
    "print num_births\n",
    "\n",
    "# check if the total number in num_births equals the toal number of counts\n",
    "#print sum(num_births)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 341,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "8"
      ]
     },
     "execution_count": 341,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# get the month with the most birthdays \n",
    "max_birth = max(num_births)\n",
    "for i in range(0,12):\n",
    "    if num_births[i] == max_birth:\n",
    "        max_birth_month = i + 1\n",
    "max_birth_month"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "August has the most number of births in 1978. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 342,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[429428, 495155, 513760, 503804, 503326, 510942, 440559]\n",
      "2\n",
      "0\n"
     ]
    }
   ],
   "source": [
    "# find which day has the most and least number of births\n",
    "\n",
    "# have a list with all the days of the week \n",
    "list_day = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday' ,'Friday', 'Saturday']\n",
    "# set the count to be equal to zero\n",
    "count2 = 0\n",
    "# set a list of just zeros\n",
    "list_of_days = [0, 0, 0, 0, 0, 0, 0]\n",
    "\n",
    "# go through the list of birthdays\n",
    "for i in range(0, len(final_format)):\n",
    "    # grab the month, date, and count from each element\n",
    "    ith_element = final_format[i]\n",
    "    the_month = ith_element[0]\n",
    "    the_date = ith_element[1]\n",
    "    the_count = ith_element[3]\n",
    "    # call the previous function to get the day of the week of 1978\n",
    "    the_day_of_the_week = day_of_week(the_month, the_date, 1978)\n",
    "    # go through each day of the week \n",
    "    for n in range(0,7):\n",
    "        # if the day of the week matches the day of the week in the list, add the counts together\n",
    "        if the_day_of_the_week == list_day[n]:\n",
    "            count2 = list_of_zeros[n]\n",
    "            count2 = count2 + the_count\n",
    "            list_of_days[n] = count2\n",
    "print list_of_days\n",
    "\n",
    "# find the day with the most birthdays\n",
    "max_day_birthdays = max(list_of_days)    \n",
    "#print max_day_birthdays\n",
    "\n",
    "# get the index of the max day of births\n",
    "for i in range(0,7):\n",
    "    if list_of_days[i] == max_day_birthdays:\n",
    "        max_day = i\n",
    "print max_day\n",
    "\n",
    "min_day_birthdays = min(list_of_days)\n",
    "#print min_day_birthdays\n",
    "\n",
    "# get the index of the least day of births \n",
    "for i in range(0,7):\n",
    "    if list_of_days[i] == min_day_birthdays:\n",
    "        min_day = i\n",
    "print min_day\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Tuesday had the most births and Sunday had the least amount of births. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Because August had the highest number of births, I can conclude that the holiday season in December has a large effect on having children. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Exercise 2.3.__ What would be an effective way to present the information in exercise 2.2? You don't need to write any code for this exercise, just discuss what you would do."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "An effective way to present the information above is to print out sentences that answers the question. "
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python [default]",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
